"""
Qualitative Logger for RAG Evaluation

Provides structured logging of RAG vs direct LLM answers for qualitative analysis.
Outputs to both CSV (for human review in Excel/Sheets) and JSON (for programmatic analysis).
"""

import csv
import json
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Any

from pydantic import BaseModel, Field


class LogEntry(BaseModel):
    """
    Schema for a single qualitative log entry.

    Captures the full picture of a RAG query: the question, what was retrieved,
    what the RAG-augmented LLM answered, and what the LLM answered on its own.
    """

    timestamp: str = Field(
        default_factory=lambda: datetime.now().isoformat(timespec="seconds"),
        description="ISO-formatted timestamp of when the entry was logged",
    )
    category: str = Field(
        default="",
        description="Question category (e.g. 'factual', 'reasoning', 'code')",
    )
    model_name: str = Field(
        default="",
        description="Name of the LLM model used (e.g. 'gemini-1.5-flash')",
    )
    question: str = Field(
        description="The original user question / query",
    )
    rag_context: str = Field(
        default="",
        description="The retrieved context that was passed to the LLM",
    )
    rag_answer: str = Field(
        default="",
        description="The answer generated by the LLM using RAG context",
    )
    llm_answer: str = Field(
        default="",
        description="The answer from the LLM without RAG (direct response)",
    )
    evaluation_scores: Optional[Dict[str, Any]] = Field(
        default=None,
        description="Optional evaluation metric scores from RAGEvaluator",
    )


# Column order for CSV output (evaluation_scores is flattened into individual columns)
_CSV_BASE_COLUMNS = [
    "timestamp",
    "category",
    "model_name",
    "question",
    "rag_context",
    "rag_answer",
    "llm_answer",
]


class QualitativeLogger:
    """
    Accumulates qualitative log entries and saves them as CSV and/or JSON.

    Usage:
        logger = QualitativeLogger()
        logger.log(LogEntry(question="What is X?", rag_answer="...", llm_answer="..."))
        logger.save("output/logs")
    """

    def __init__(self) -> None:
        self._entries: List[LogEntry] = []

    @property
    def entries(self) -> List[LogEntry]:
        """Return a copy of the accumulated entries."""
        return list(self._entries)

    def __len__(self) -> int:
        return len(self._entries)

    def log(self, entry: LogEntry) -> None:
        """Append a single log entry."""
        self._entries.append(entry)

    def log_batch(self, entries: List[LogEntry]) -> None:
        """Append multiple log entries at once."""
        self._entries.extend(entries)

    # ------------------------------------------------------------------
    # Serialisation helpers
    # ------------------------------------------------------------------

    def _collect_score_columns(self) -> List[str]:
        """Determine the union of all metric names across entries."""
        columns: dict[str, None] = {}  # ordered set
        for entry in self._entries:
            if entry.evaluation_scores:
                for key in entry.evaluation_scores:
                    columns[key] = None
        return list(columns)

    def _entry_to_flat_dict(self, entry: LogEntry, score_columns: List[str]) -> Dict[str, Any]:
        """Convert a LogEntry to a flat dict suitable for CSV row writing."""
        row: Dict[str, Any] = {}
        for col in _CSV_BASE_COLUMNS:
            row[col] = getattr(entry, col)

        scores = entry.evaluation_scores or {}
        for col in score_columns:
            value = scores.get(col)
            # Extract numeric score from metric result dicts
            if isinstance(value, dict) and "score" in value:
                value = value["score"]
            row[col] = value if value is not None else ""

        return row

    def _entry_to_json_dict(self, entry: LogEntry) -> Dict[str, Any]:
        """Convert a LogEntry to a dict suitable for JSON serialisation."""
        data = entry.model_dump()
        # Strip None evaluation_scores for cleaner output
        if data.get("evaluation_scores") is None:
            del data["evaluation_scores"]
        return data

    # ------------------------------------------------------------------
    # Save
    # ------------------------------------------------------------------

    def save(
        self,
        output_dir: str = "logs",
        formats: Optional[List[str]] = None,
        filename_prefix: str = "qualitative_log",
    ) -> Dict[str, str]:
        """
        Write accumulated entries to disk.

        Args:
            output_dir: Directory to write log files into (created if missing).
            formats: List of formats to write. Defaults to ``["csv", "json"]``.
            filename_prefix: Prefix for the generated filenames.

        Returns:
            Dictionary mapping format name to the written file path.
        """
        if formats is None:
            formats = ["csv", "json"]

        out_path = Path(output_dir)
        out_path.mkdir(parents=True, exist_ok=True)

        timestamp_slug = datetime.now().strftime("%Y-%m-%d_%H%M%S")
        written: Dict[str, str] = {}

        if "csv" in formats:
            csv_file = out_path / f"{filename_prefix}_{timestamp_slug}.csv"
            self._write_csv(csv_file)
            written["csv"] = str(csv_file)

        if "json" in formats:
            json_file = out_path / f"{filename_prefix}_{timestamp_slug}.json"
            self._write_json(json_file)
            written["json"] = str(json_file)

        return written

    def _write_csv(self, file_path: Path) -> None:
        """Write all entries to a CSV file."""
        score_columns = self._collect_score_columns()
        fieldnames = _CSV_BASE_COLUMNS + score_columns

        with open(file_path, "w", newline="", encoding="utf-8") as f:
            writer = csv.DictWriter(f, fieldnames=fieldnames)
            writer.writeheader()
            for entry in self._entries:
                writer.writerow(self._entry_to_flat_dict(entry, score_columns))

    def _write_json(self, file_path: Path) -> None:
        """Write all entries to a JSON file."""
        data = [self._entry_to_json_dict(entry) for entry in self._entries]
        with open(file_path, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=2, ensure_ascii=False)
